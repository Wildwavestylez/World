<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expanze polygonu s rozlohou a obyvateli</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        #map {
            width: 100%;
            height: 78vh;
        }
        #info {
            padding: 16px;
            background: white;
            border-top: 1px solid #ccc;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="map"></div>

  <div id="controls">
        <button id="buildGarage" onclick="placeGarage()">Postavit gar√°≈æ √∫dr≈æby</button>
<button id="buyVehicle" onclick="buyMaintenanceVehicle()">Koupit √∫dr≈æbov√© auto</button>
<button id="sendMaintenance" onclick="sendMaintenanceVehicle()">Vyslat √∫dr≈æbu</button>
<button onclick="clearLocalStorage()">Vymazat LocalStorage</button>
    </div>  
    <div id="info">Pen√≠ze: <span id="money">20000</span> Kƒç | Rozloha: <span id="area">0</span> km¬≤ | Poƒçet obyvatel: <span id="population">0</span></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map = L.map('map').setView([49.1151400, 13.8285094], 15); // Lƒçovice jako start
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap'
        }).addTo(map);

        let center = [49.1151400, 13.8285094];

        let polygonPoints = [
            [center[0] + 0.002, center[1] - 0.002],
            [center[0] + 0.002, center[1] + 0.002],
            [center[0] - 0.002, center[1] + 0.002],
            [center[0] - 0.002, center[1] - 0.002]
        ];

        let polygon = L.polygon(polygonPoints, { color: 'blue' }).addTo(map);

        let blockedPoints = {};
        let moveTracker = Array(polygonPoints.length).fill(0);

        let populationDensity = 130; // Hustota zalidnƒõn√≠ (obyvatel/km¬≤) ‚Äì m≈Ø≈æe se upravit podle oblasti


    let roadLayer = L.layerGroup().addTo(map);

    let roads = []; // Seznam v≈°ech √∫sek≈Ø silnic

let roadSegments = []; // Seznam segment≈Ø silnic

    // Definice ikony pro √∫dr≈æbov√© auto
const maintenanceVehicleIcon = L.icon({
    iconUrl: 'https://i.imgur.com/Cwm3M4Z.png',
    iconSize: [24, 24]
});

function fetchRoads(bounds) {
    let query = `[out:json];way["highway"~"primary|secondary|tertiary|residential|unclassified|motorway"]( ${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()});out geom;`;

    fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`)
        .then(response => response.json())
        .then(data => {
            let savedSegments = JSON.parse(localStorage.getItem("repairedRoads")) || {};
            data.elements.forEach(way => {
                let coordinates = way.geometry.map(node => [node.lat, node.lon]);
                let segmentId = way.id;

                let segmentColor = savedSegments[segmentId] || "red"; // Pokud je v localStorage, pou≈æijeme ulo≈æenou barvu

                let polyline = L.polyline(coordinates, { color: segmentColor, weight: 3 }).addTo(map);

                roadSegments.push({ id: segmentId, coordinates, polyline, status: segmentColor });
            });
        })
        .catch(error => console.error("‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ silnic:", error));
}


// Funkce pro rozdƒõlen√≠ silnice na √∫seky po 200 metrech
function splitRoadIntoSegments(coords, segmentLength) {
    let segments = [];
    let currentSegment = [];
    let accumulatedDistance = 0;

    for (let i = 0; i < coords.length - 1; i++) {
        let pointA = L.latLng(coords[i]);
        let pointB = L.latLng(coords[i + 1]);
        let distance = pointA.distanceTo(pointB);

        if (accumulatedDistance + distance >= segmentLength) {
            segments.push([...currentSegment, pointB]);
            currentSegment = [pointB];
            accumulatedDistance = 0;
        } else {
            currentSegment.push(pointB);
            accumulatedDistance += distance;
        }
    }

    if (currentSegment.length > 1) {
        segments.push(currentSegment);
    }

    return segments;
}

// Naƒçten√≠ silnic po otev≈ôen√≠ mapy
fetchRoads(map.getBounds());
map.on('moveend', () => {
    fetchRoads(map.getBounds());
});


    function getMaintenancePath(startLocation) {
    let path = [];
    let closestRoad = findNearestRoad(startLocation);

    if (!closestRoad) return path; // Pokud nen√≠ bl√≠zk√° silnice, nevrac√≠me nic

    let currentSegment = closestRoad;

    while (path.length < 50) { // Max d√©lka trasy, aby se nekoneƒçnƒõ necyklilo
        path.push(currentSegment.coordinates);
        let nextSegment = findNextRoadSegment(currentSegment);
        if (!nextSegment) break;
        currentSegment = nextSegment;
    }

    return path;
}

function findNearestRoad(location) {
    let nearestRoad = null;
    let minDistance = Infinity;

    roadSegments.forEach(segment => {
        let dist = distance(location, segment.coordinates[0]); // Prvn√≠ bod silnice
        if (dist < minDistance) {
            minDistance = dist;
            nearestRoad = segment;
        }
    });

    return nearestRoad;
}

function findNextRoadSegment(currentSegment) {
    let nextSegment = null;

    roadSegments.forEach(segment => {
        if (segment !== currentSegment && isConnected(currentSegment, segment)) {
            nextSegment = segment;
        }
    });

    return nextSegment;
}

function isConnected(segmentA, segmentB) {
    let lastPointA = segmentA.coordinates[segmentA.coordinates.length - 1];
    let firstPointB = segmentB.coordinates[0];

    return distance(lastPointA, firstPointB) < 0.001; // Men≈°√≠ ne≈æ 100m
}

// V√Ωpoƒçet vzd√°lenosti dvou bod≈Ø
function distance(coord1, coord2) {
    let latDiff = coord1[0] - coord2[0];
    let lonDiff = coord1[1] - coord2[1];
    return Math.sqrt(latDiff * latDiff + lonDiff * lonDiff);
}

        function getCentroid(points) {
            let latSum = 0, lngSum = 0;
            points.forEach(p => { latSum += p[0]; lngSum += p[1]; });
            return [latSum / points.length, lngSum / points.length];
        }

        function movePointAway(point, center, distance) {
            let latDiff = point[0] - center[0];
            let lngDiff = point[1] - center[1];
            let length = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
            let scale = distance / length;
            return [point[0] + latDiff * scale, point[1] + lngDiff * scale];
        }

        function calculatePolygonArea(points) {
            let earthRadius = 6371; // Polomƒõr Zemƒõ v km
            let area = 0;
            let n = points.length;

            for (let i = 0; i < n; i++) {
                let p1 = points[i];
                let p2 = points[(i + 1) % n];

                let lat1 = p1[0] * Math.PI / 180;
                let lon1 = p1[1] * Math.PI / 180;
                let lat2 = p2[0] * Math.PI / 180;
                let lon2 = p2[1] * Math.PI / 180;

                area += (lon2 - lon1) * (2 + Math.sin(lat1) + Math.sin(lat2));
            }

            area = Math.abs(area * earthRadius * earthRadius / 2);
            return area;
        }

        function expandPolygon() {
            let center = getCentroid(polygonPoints);
            let totalPoints = polygonPoints.length;
            let maxWaitTurns = Math.floor(1.5 * totalPoints);

            let availablePoints = polygonPoints
                .map((point, index) => ({ point, index }))
                .filter(({ index }) => !blockedPoints[index]);

            if (availablePoints.length === 0) return;

            let forcedMoveIndex = moveTracker.indexOf(Math.max(...moveTracker));
            let mustMove = moveTracker[forcedMoveIndex] >= maxWaitTurns;

            let selectedIndex;
            if (mustMove) {
                selectedIndex = forcedMoveIndex;
            } else {
                let randomPoint = availablePoints[Math.floor(Math.random() * availablePoints.length)];
                selectedIndex = randomPoint.index;
            }

            polygonPoints[selectedIndex] = movePointAway(polygonPoints[selectedIndex], center, 0.0015);

            moveTracker[selectedIndex] = 0;
            blockedPoints[selectedIndex] = Date.now() + (totalPoints / 2) * 1000;

            for (let i = 0; i < moveTracker.length; i++) {
                if (i !== selectedIndex) moveTracker[i]++;
            }

            for (let i = 0; i < polygonPoints.length; i++) {
                let p1 = polygonPoints[i];
                let p2 = polygonPoints[(i + 1) % polygonPoints.length];

                let distance = Math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2);
                if (distance > 0.005) {
                    let midPoint = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
                    polygonPoints.splice(i + 1, 0, midPoint);
                    moveTracker.splice(i + 1, 0, 0);
                    break;
                }
            }

            polygon.setLatLngs(polygonPoints);

            let area = calculatePolygonArea(polygonPoints);
            let population = Math.round(area * populationDensity);

            document.getElementById("area").textContent = area.toFixed(2);
            document.getElementById("population").textContent = population.toLocaleString();
        }

        function unlockBlockedPoints() {
            let currentTime = Date.now();
            for (let index in blockedPoints) {
                if (currentTime >= blockedPoints[index]) {
                    delete blockedPoints[index];
                }
            }
        }

        setInterval(() => {
            expandPolygon();
            unlockBlockedPoints();
        }, 1000);


    let garages = []; // Seznam gar√°≈æ√≠
let maintenanceCars = []; // Seznam aut √∫dr≈æby
let garagePrice = 100; // Cena prvn√≠ gar√°≈æe
let carPrice = 50; // Cena prvn√≠ho auta
let money = 20000; // Poƒç√°teƒçn√≠ stav penƒõz hr√°ƒçe
    let tollBooths = []; // Seznam m√Ωtn√Ωch bran

    function updateMoneyDisplay() {
            document.getElementById("money").textContent = money.toLocaleString();
        }

    function placeTollBooth(latlng) {
    if (money < 5000) {
        alert("Nem√°≈° dost penƒõz na m√Ωtnou br√°nu!");
        return;
    }

    let confirmation = confirm("Chce≈° postavit m√Ωtnou br√°nu za 5000 Kƒç?");
    if (!confirmation) {
        return; // Pokud hr√°ƒç klikne na "Ne", funkce se ukonƒç√≠
    }

    money -= 5000; // Odeƒçten√≠ ceny za m√Ωtnou br√°nu
    updateMoneyDisplay();

    let icon = L.icon({
        iconUrl: "https://i.imgur.com/U2n0VLa.png",
        iconSize: [32, 32]
    });

    let marker = L.marker(latlng, { icon }).addTo(map);
    tollBooths.push(marker);

    // Generov√°n√≠ penƒõz ka≈æd√Ωch 20 sekund
    setInterval(() => {
        money += 25;
        updateMoneyDisplay();
    }, 15000);
}

// P≈ôid√°n√≠ mo≈ænosti kliknut√≠m na silnici um√≠stit m√Ωtnou br√°nu
map.on("click", function (e) {
    let clickedLatLng = e.latlng;
    placeTollBooth(clickedLatLng);
});

updateMoneyDisplay();


function placeGarage() {
    if (money < garagePrice) {
        alert("Nedostatek penƒõz!");
        return;
    }

    money -= garagePrice;
    garagePrice += 500; // Ka≈æd√° dal≈°√≠ gar√°≈æ je dra≈æ≈°√≠

    map.once('click', function (event) {
        let garage = {
            location: event.latlng,
            marker: L.marker(event.latlng, { icon: L.icon({ iconUrl: 'https://i.imgur.com/puN4S0i.jpeg', iconSize: [32, 32] }) })
        };

        garage.marker.addTo(map).bindPopup("Gar√°≈æ √∫dr≈æby");
        garages.push(garage);
    });
}

// Tlaƒç√≠tko pro stavbu gar√°≈æe
document.getElementById('buildGarage').addEventListener('click', placeGarage);


        let maintenanceVehicles = []; // Seznam √∫dr≈æbov√Ωch aut
let vehiclePrice = 50; // Cena prvn√≠ho auta

function buyMaintenanceVehicle() {
    if (garages.length === 0) {
        alert("Nem√°te ≈æ√°dnou gar√°≈æ!");
        return;
    }
    if (money < vehiclePrice) {
        alert("Nedostatek penƒõz!");
        return;
    }

    money -= vehiclePrice;
    vehiclePrice += 200; // Ka≈æd√© dal≈°√≠ auto je dra≈æ≈°√≠

    let garage = garages[0]; // Prvn√≠ dostupn√° gar√°≈æ

    let vehicle = {
        location: garage.location,
        marker: L.marker(garage.location, { icon: L.icon({ iconUrl: 'https://i.imgur.com/Cwm3M4Z.png', iconSize: [24, 24] }) }),
        moving: false,
        assignedSegments: [] // Ka≈æd√© auto bude m√≠t sv≈Øj vlastn√≠ seznam oprav
    };

    vehicle.marker.addTo(map).bindPopup("√ödr≈æbov√© auto");
    maintenanceVehicles.push(vehicle);

    assignSegmentsToVehicles(); // P≈ôerozdƒõl√≠me √∫seky mezi auta
}

function assignSegmentsToVehicles() {
    let repairableSegments = roadSegments.filter(s => s.status === "red" || s.status === "orange");

    if (repairableSegments.length === 0) {
        console.log("‚úÖ V≈°echny silnice jsou opraven√©!");
        return;
    }

    maintenanceVehicles.forEach(vehicle => vehicle.assignedSegments = []); // Resetujeme p≈ôidƒõlen√© √∫seky

    repairableSegments.forEach((segment, index) => {
        let vehicleIndex = index % maintenanceVehicles.length; // Rozdƒõlen√≠ √∫sek≈Ø rovnomƒõrnƒõ mezi auta
        maintenanceVehicles[vehicleIndex].assignedSegments.push(segment);
    });

    maintenanceVehicles.forEach(vehicle => moveVehicleToSegment(vehicle));
}

function sendMaintenanceVehicle(garageLocation) {
    if (!roadSegments || roadSegments.length === 0) {
        console.warn("üöß ≈Ω√°dn√© dostupn√© silnice k opravƒõ!");
        return;
    }

    let vehicle = maintenanceVehicles.find(v => !v.moving);
    if (!vehicle) {
        console.warn("üöó V≈°echna √∫dr≈æbov√° auta jsou obsazena!");
        return;
    }

    // Najdeme segment, kter√Ω je≈°tƒõ nen√≠ p≈ôi≈ôazen ≈æ√°dn√©mu autu
    let segment = roadSegments.find(s => (s.status === "red" || s.status === "orange") && 
                                         isInsidePolygon(L.latLng(s.coordinates[0])));

    if (!segment) {
        console.warn("‚úÖ V≈°echny silnice v oblasti jsou opraven√©!");
        return;
    }

    vehicle.moving = true;
    vehicle.assignedSegments.push(segment);

    moveVehicleToSegment(vehicle);
}

function isInsidePolygon(latLng) { return polygon.getBounds().contains(latLng); }

function getRoute(start, end) {
    if (!start || !end) {
        console.error("‚ùå Chyba: Neplatn√© sou≈ôadnice pro trasu!");
        return [];
    }

    let route = [];
    let steps = 20; // Poƒçet mezikrok≈Ø mezi startem a c√≠lem
    for (let i = 0; i <= steps; i++) {
        let lat = start.lat + (end.lat - start.lat) * (i / steps);
        let lng = start.lng + (end.lng - start.lng) * (i / steps);
        route.push([lat, lng]);
    }
    return route;
}

function getRoute(segment) {
    if (!segment || !segment.coordinates || segment.coordinates.length === 0) {
        console.error("‚ùå Chyba: Segment nem√° platn√© sou≈ôadnice!");
        return [];
    }

    return segment.coordinates; // Pou≈æijeme body segmentu jako trasu
}

function moveVehicleToSegment(vehicle) {
    if (vehicle.assignedSegments.length === 0) {
        console.log(`üöó Auto ${vehicle.marker._leaflet_id} nem√° ≈æ√°dn√© √∫seky k opravƒõ.`);
        return;
    }

    let segment = vehicle.assignedSegments.shift();
    if (!segment) {
        console.log(`üöó Auto ${vehicle.marker._leaflet_id} u≈æ opravilo v≈°echny √∫seky.`);
        return;
    }

    console.log(`üöó Auto ${vehicle.marker._leaflet_id} jede opravit silnici ${segment.id}`);

    let route = getRoute(vehicle.marker.getLatLng(), segment.coordinates);
    if (!route || route.length === 0) {
        console.error(`‚ùå Chyba: Nelze vypoƒç√≠tat trasu pro auto ${vehicle.marker._leaflet_id}!`);
        return;
    }

    vehicle.moving = true;
    animateVehicleAlongRoute(vehicle, route, () => {
        console.log(`‚úÖ Auto ${vehicle.marker._leaflet_id} dorazilo na silnici ${segment.id}`);

        setTimeout(() => {
            repairSegment(segment);
            vehicle.moving = false;
            moveVehicleToSegment(vehicle); // Pokraƒçuje na dal≈°√≠ √∫sek
        }, 20000); // Oprava trv√° 20 sekund
    });
}

function animateVehicleAlongRoute(vehicle, route, callback) {
    let currentIndex = 0;
    function moveStep() {
        if (currentIndex < route.length) {
            let nextPoint = L.latLng(route[currentIndex]);
            vehicle.marker.setLatLng(nextPoint);
            currentIndex++;
            setTimeout(moveStep, 300); // Pohyb auta ka≈æd√Ωch 300 ms
        } else {
            callback(); // Po dokonƒçen√≠ animace zavol√°me opravu
        }
    }
    moveStep();
}

function getRoute(start, roadPoints) {
    if (!start || roadPoints.length === 0) return [];

    let nearestStart = roadPoints.reduce((a, b) => 
        start.distanceTo(L.latLng(a)) < start.distanceTo(L.latLng(b)) ? a : b
    );

    let routeIndex = roadPoints.findIndex(p => p[0] === nearestStart[0] && p[1] === nearestStart[1]);
    return roadPoints.slice(routeIndex); // Vrac√≠me trasu od nejbli≈æ≈°√≠ho bodu
}
// Funkce pro naƒç√≠t√°n√≠ stavu segment≈Ø p≈ôi // Funkce pro naƒç√≠t√°n√≠ stavu segment≈Ø p≈ôi naƒçten√≠ hry
function loadSegmentStatus() {  
    let savedSegments = JSON.parse(localStorage.getItem("repairedRoads")) || {};  

    roadSegments.forEach(segment => {  
        if (savedSegments[segment.id]) {  
            segment.status = savedSegments[segment.id].status; // Pou≈æijeme ulo≈æen√Ω status  

            if (segment.status === "green") {  
                // Pokud je segment zelen√Ω, odstran√≠me ho z mapy
                if (segment.polyline) {
                    map.removeLayer(segment.polyline);
                }
                console.log(`üü¢ Segment ${segment.id} byl opraven na zeleno a nebude vykreslen.`);
                return; // P≈ôeskoƒç√≠me vykreslen√≠  
            }  

            // Aktualizujeme barvu segmentu na mapƒõ  
            updateSegmentColor(segment);
        }  
    });  
}

// Funkce pro aktualizaci barvy segmentu  
// Funkce pro aktualizaci barvy segmentu
function updateSegmentColor(segment) {
    if (segment.status === "green") {
        // Pokud je segment zelen√Ω, √∫plnƒõ ho odstran√≠me z mapy po 1 minutƒõ
        if (segment.polyline) {
            setTimeout(() => {
                map.removeLayer(segment.polyline);
                segment.polyline = null;
                console.log(`üü¢ Segment ${segment.id} byl odstranƒõn z mapy po 1 minutƒõ.`);
            }, 60000); // 1 minuta v milisekund√°ch
        }
        return;
    }

    let color = segment.status === "orange" ? "orange" : "red";  

    if (segment.polyline) {  
        segment.polyline.setStyle({ color: color });  
    } else {  
        segment.polyline = L.polyline(segment.coordinates, { color: color, weight: 3 }).addTo(map);  
    }  

    console.log(`üé® Segment ${segment.id} nastaven na barvu ${color}.`);
}

// Funkce pro opravu segmentu a zmƒõnu barvy na zelenou
function repairSegment(segment) {
    if (money < 70) {
        alert("Nedostatek penƒõz na opravu!");
        return;
    }

    money -= 70;
    updateMoneyDisplay();

    if (!segment || !segment.polyline) {
        console.error("‚ùå Chyba: Segment nebo polyline neexistuje!");
        return;
    }

    let newColor;
    if (segment.status === "red") {
        segment.status = "orange"; // Prvn√≠ oprava, zmƒõn√≠ na oran≈æovou
    } else if (segment.status === "orange") {
        segment.status = "green"; // Druh√° oprava, zmƒõn√≠ na zelenou
    } else {
        console.warn("‚ö† Silnice u≈æ je zelen√°.");
        return;
    }

    newColor = segment.status;

    // Ulo≈æ√≠me opraven√Ω segment do localStorage
    let savedSegments = JSON.parse(localStorage.getItem("repairedRoads")) || {};
    savedSegments[segment.id] = { status: newColor, lastRepaired: Date.now() }; 
    localStorage.setItem("repairedRoads", JSON.stringify(savedSegments));

    // Aktualizujeme barvu polyline
    map.removeLayer(segment.polyline);
    segment.polyline = L.polyline(segment.coordinates, { color: newColor, weight: 3 }).addTo(map);

    console.log(`‚úÖ Silnice opravena! Nov√° barva: ${newColor}`);

    // Odstran√≠me segment po 1 minutƒõ, kdy≈æ je zelen√Ω
    if (segment.status === "green") {
        setTimeout(() => {
            map.removeLayer(segment.polyline);
            segment.polyline = null;
            console.log(`üü¢ Segment ${segment.id} byl odstranƒõn z mapy po 1 minutƒõ.`);
        }, 60000); // 1 minuta v milisekund√°ch
    }
}


function clearLocalStorage() {
    localStorage.clear();
    alert("LocalStorage byl vymaz√°n!");
  }

/// Seznam firem ƒçekaj√≠c√≠ch na licenci
let waitingBusinesses = [];
let approvedBusinesses = [];

// Funkce pro z√≠sk√°n√≠ firem v polygonu p≈ôes Overpass API
function fetchBusinessesInPolygon(polygonPoints) {
    let overpassQuery = `
    [out:json];
    (
        node["shop"](poly:"${polygonPoints.map(p => p.join(' ')).join(' ')}");
        node["amenity"](poly:"${polygonPoints.map(p => p.join(' ')).join(' ')}")
            ["amenity"~"restaurant|cafe|bar|pub|bank|fuel|pharmacy|hospital|clinic|fast_food|supermarket|convenience|marketplace|townhall|library|school|kindergarten|university|fire_station|police|post_office"];
        node["craft"](poly:"${polygonPoints.map(p => p.join(' ')).join(' ')}");
        node["industrial"](poly:"${polygonPoints.map(p => p.join(' ')).join(' ')}");
        node["man_made"="works"](poly:"${polygonPoints.map(p => p.join(' ')).join(' ')}");
        node["building"](poly:"${polygonPoints.map(p => p.join(' ')).join(' ')}")
            ["building"~"industrial|factory|manufacture|warehouse|logistics|retail|department_store|wholesale|mall|supermarket|public"];
        node["landuse"](poly:"${polygonPoints.map(p => p.join(' ')).join(' ')}")
            ["landuse"~"industrial|commercial"];
        node["office"](poly:"${polygonPoints.map(p => p.join(' ')).join(' ')}")
            ["office"~"company|industrial"];
        node["power"](poly:"${polygonPoints.map(p => p.join(' ')).join(' ')}")
            ["power"="plant"];
    );
    out body;`;
    fetch("https://overpass-api.de/api/interpreter", {
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded"
        },
        body: `data=${encodeURIComponent(overpassQuery)}`
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Chyba p≈ôi naƒç√≠t√°n√≠ firem: ' + response.statusText);
        }
        return response.json();
    })
    .then(data => {
        if (!data || !data.elements || data.elements.length === 0) {
            console.log('Nebyly nalezeny ≈æ√°dn√© firmy.');
            return;
        }

        let newBusinesses = data.elements
            .filter(element => element.tags.name) // Filtrujeme jen firmy, kter√© maj√≠ jm√©no
            .map(element => ({
                id: element.id,
                name: element.tags.name,
                type: element.tags.shop || element.tags.amenity || element.tags.craft || "Jin√©",
                lat: element.lat,
                lon: element.lon
            }));

        let addedNewBusiness = false;

        newBusinesses.forEach(business => {
            if (!waitingBusinesses.some(b => b.id === business.id) &&
                !approvedBusinesses.some(b => b.id === business.id)) {
                waitingBusinesses.push(business);
                addedNewBusiness = true; // Oznaƒç√≠me, ≈æe jsme p≈ôidali novou firmu
            }
        });

        console.log("ƒåekac√≠ listina firem:", waitingBusinesses);

        // Pokud byla p≈ôid√°na nov√° firma, okam≈æitƒõ spust√≠me ≈æ√°dost o licenci
        if (addedNewBusiness) {
            requestBusinessLicense();
        }
    })
    .catch(error => {
        console.error("Chyba p≈ôi naƒç√≠t√°n√≠ firem:", error);
    });
}
// Funkce pro v√Ωbƒõr firmy k ≈æ√°dosti o licenci
function requestBusinessLicense() {
    if (waitingBusinesses.length === 0) return;

    let randomIndex = Math.floor(Math.random() * waitingBusinesses.length);
    let business = waitingBusinesses.splice(randomIndex, 1)[0];

    let confirmation = confirm(`Firma "${business.name}" (${business.type}) ≈æ√°d√° o licenci k podnik√°n√≠. Udƒõlit licenci?`);

    if (confirmation) {
        approvedBusinesses.push(business);
        console.log(`Firma ${business.name} schv√°lena, zaƒçne platit danƒõ.`);
    } else {
        console.log(`Firma ${business.name} zam√≠tnuta.`);
    }
}

let totalTaxes = 0;  // Celkov√© danƒõ

// Funkce pro v√Ωpoƒçet dan√≠ na z√°kladƒõ poƒçtu obyvatel
function calculateTaxes(population) {
    return Math.round((population / 100) * 5); // 5 Kƒç na ka≈æd√Ωch 100 obyvatel
}

// Funkce pro aktualizaci pokladny (p≈ôiƒçten√≠ dan√≠)
function updateMoney() {
    let population = Math.round(calculatePolygonArea(polygonPoints) * populationDensity);
    let taxes = calculateTaxes(population);

    // P≈ôiƒçteme danƒõ z firem
    approvedBusinesses.forEach(business => {
        taxes += 20; // Ka≈æd√° schv√°len√° firma plat√≠ 20 Kƒç da≈à za minutu
    });

    money += taxes;  // P≈ôiƒç√≠t√°me danƒõ do pokladny
    totalTaxes += taxes;

    console.log(`Danƒõ za tuto minutu: ${taxes.toLocaleString()} Kƒç`);
    console.log(`Celkov√© danƒõ: ${totalTaxes.toLocaleString()} Kƒç`);

    // Aktualizace zobrazen√≠ penƒõz
    updateMoneyDisplay();
}



// Funkce pro aktualizaci zobrazen√≠ stavu pokladny
function updateMoneyDisplay() {
    document.getElementById("money").textContent = money.toLocaleString();
}

// Zavol√°me funkci ka≈ædou minutu (60000 ms)
setInterval(updateMoney, 60000); // Ka≈æd√Ωch 60 sekund

// Periodick√© fetchov√°n√≠ firem a ≈æ√°dost√≠ o licenci
setInterval(() => fetchBusinessesInPolygon(polygonPoints), 120000); // Ka≈æd√© 2 minuty
setInterval(() => requestBusinessLicense(), 120000); // Ka≈æd√© 2 minuty
</script>
</body>
</html>