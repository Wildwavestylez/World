<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expanze polygonu s rozlohou a obyvateli</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        #map {
            width: 100%;
            height: 78vh;
        }
        #info {
            padding: 16px;
            background: white;
            border-top: 1px solid #ccc;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="map"></div>

  <div id="controls">
        <button id="buildGarage" onclick="placeGarage()">Postavit garáž údržby</button>
<button id="buyVehicle" onclick="buyMaintenanceVehicle()">Koupit údržbové auto</button>
<button id="sendMaintenance" onclick="sendMaintenanceVehicle()">Vyslat údržbu</button>
<button onclick="clearLocalStorage()">Vymazat LocalStorage</button>
    </div>  
    <div id="info">| Rozloha: <span id="area">0</span> km² | Počet obyvatel: <span id="population">0</span></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map = L.map('map').setView([49.1675000, 13.8898087], 15); // Lčovice jako start
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap'
        }).addTo(map);

        let center = [49.1675000, 13.8898087];

        let savedPolygon = localStorage.getItem("polygonPoints");
let currentIndex = 0;
let polygonPoints;

if (savedPolygon) {
    polygonPoints = JSON.parse(savedPolygon);
} else {
    polygonPoints = [
        [center[0] + 0.002, center[1] - 0.002],
        [center[0] + 0.002, center[1] + 0.002],
        [center[0] - 0.002, center[1] + 0.002],
        [center[0] - 0.002, center[1] - 0.002]
    ];
}


        let polygon = L.polygon(polygonPoints, { color: 'blue' }).addTo(map);

        let blockedPoints = {};
        let moveTracker = Array(polygonPoints.length).fill(0);

        let populationDensity = 130; // Hustota zalidnění (obyvatel/km²) – může se upravit podle oblasti


function isConnected(segmentA, segmentB) {
    let lastPointA = segmentA.coordinates[segmentA.coordinates.length - 1];
    let firstPointB = segmentB.coordinates[0];

    return distance(lastPointA, firstPointB) < 0.001; // Menší než 100m
}

// Výpočet vzdálenosti dvou bodů
function distance(coord1, coord2) {
    let latDiff = coord1[0] - coord2[0];
    let lonDiff = coord1[1] - coord2[1];
    return Math.sqrt(latDiff * latDiff + lonDiff * lonDiff);
}

        function getCentroid(points) {
            let latSum = 0, lngSum = 0;
            points.forEach(p => { latSum += p[0]; lngSum += p[1]; });
            return [latSum / points.length, lngSum / points.length];
        }

        function movePointFromEdge(pointIndex, distance) {
    let total = polygonPoints.length;
    let prev = polygonPoints[(pointIndex - 1 + total) % total];
    let curr = polygonPoints[pointIndex];
    let next = polygonPoints[(pointIndex + 1) % total];

    // Spočítej tangentu (okraj polygonu)
    let tangentLat = next[0] - prev[0];
    let tangentLng = next[1] - prev[1];

    // Normála (kolmá na tangentu)
    let normalLat = -tangentLng;
    let normalLng = tangentLat;

    // Jednotkový vektor
    let length = Math.sqrt(normalLat * normalLat + normalLng * normalLng);
    normalLat /= length;
    normalLng /= length;

    // Směr ke středu
    let center = getCentroid(polygonPoints);
    let toCenterLat = center[0] - curr[0];
    let toCenterLng = center[1] - curr[1];

    // Ověření: je-li úhel mezi normálou a vektorem ke středu < 90°, normála míří dovnitř → OTOČIT
    let dot = normalLat * toCenterLat + normalLng * toCenterLng;
    if (dot > 0) {
        normalLat = -normalLat;
        normalLng = -normalLng;
    }

    // Přidej náhodný úhel (±30°)
    let angleOffset = (Math.random() - 0.5) * (Math.PI / 3); // ±30°
    let cosA = Math.cos(angleOffset);
    let sinA = Math.sin(angleOffset);

    let rotatedLat = normalLat * cosA - normalLng * sinA;
    let rotatedLng = normalLat * sinA + normalLng * cosA;

    return [
        curr[0] + rotatedLat * distance,
        curr[1] + rotatedLng * distance
    ];
}     function calculatePolygonArea(points) {
            let earthRadius = 6371; // Poloměr Země v km
            let area = 0;
            let n = points.length;

            for (let i = 0; i < n; i++) {
                let p1 = points[i];
                let p2 = points[(i + 1) % n];

                let lat1 = p1[0] * Math.PI / 180;
                let lon1 = p1[1] * Math.PI / 180;
                let lat2 = p2[0] * Math.PI / 180;
                let lon2 = p2[1] * Math.PI / 180;

                area += (lon2 - lon1) * (2 + Math.sin(lat1) + Math.sin(lat2));
            }

            area = Math.abs(area * earthRadius * earthRadius / 2);
            return area;
        }

        let turn = 0; // Přidáme proměnnou pro sledování počtu tahů

function expandPolygon() {
    turn++;

    let center = getCentroid(polygonPoints);
    let totalPoints = polygonPoints.length;

    let selectedIndex = currentIndex;

    // Náhodná vzdálenost mezi 200 a 600 metrů (přibližně)
    let distance = 0.0018 + Math.random() * 0.004; // cca 200–600 m

    let selectedPoint = polygonPoints[selectedIndex];
let isInside = isPointInsidePolygon(selectedPoint, polygonPoints);

if (isInside) {
    // Bod leží uvnitř polygonu – vytlačit přímo od středu ven
    polygonPoints[selectedIndex] = movePointAway(selectedPoint, getCentroid(polygonPoints), distance);
} else {
    // Bod je na okraji – použít „chytřejší“ rozvětvující pohyb
    polygonPoints[selectedIndex] = movePointFromEdge(selectedIndex, distance);
}// Zaznamenání posunu + cooldown
    moveTracker[selectedIndex] = 0;
    blockedPoints[selectedIndex] = Date.now() + (totalPoints / 2) * 1000;

    // Zvýšení trackeru u ostatních bodů
    for (let i = 0; i < moveTracker.length; i++) {
        if (i !== selectedIndex) moveTracker[i]++;
    }

    // Přidání nového bodu, pokud je úsek moc dlouhý
    for (let i = 0; i < polygonPoints.length; i++) {
        let p1 = polygonPoints[i];
        let p2 = polygonPoints[(i + 1) % polygonPoints.length];

        let segmentLength = distanceBetween(p1, p2);
        if (segmentLength > 0.023) {
            let midPoint = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
            polygonPoints.splice(i + 1, 0, midPoint);
            moveTracker.splice(i + 1, 0, 0);
            // Úprava currentIndex, aby se zachovalo pořadí
            if (currentIndex > i) currentIndex++;
            break;
        }
    }

    // Posun na další bod
    currentIndex = (currentIndex + 1) % polygonPoints.length;

    polygon.setLatLngs(polygonPoints);

    let area = calculatePolygonArea(polygonPoints);
    let population = Math.round(area * populationDensity);

    localStorage.setItem("polygonPoints", JSON.stringify(polygonPoints));

    document.getElementById("area").textContent = area.toFixed(2);
    document.getElementById("population").textContent = population.toLocaleString();
}


function isPointInsidePolygon(point, polygonArray) {
    let x = point[1], y = point[0];
    let inside = false;

    for (let i = 0, j = polygonArray.length - 1; i < polygonArray.length; j = i++) {
        let xi = polygonArray[i][1], yi = polygonArray[i][0];
        let xj = polygonArray[j][1], yj = polygonArray[j][0];

        let intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi + 0.00000001) + xi);
        if (intersect) inside = !inside;
    }

    return inside;
}

function distanceBetween(p1, p2) {
    let latDiff = p2[0] - p1[0];
    let lngDiff = p2[1] - p1[1];
    return Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
}

        function unlockBlockedPoints() {
            let currentTime = Date.now();
            for (let index in blockedPoints) {
                if (currentTime >= blockedPoints[index]) {
                    delete blockedPoints[index];
                }
            }
        }

        setInterval(() => {
            expandPolygon();
            unlockBlockedPoints();
        }, 1000);



// Inicializační výpočet po načtení
polygon.setLatLngs(polygonPoints);
let initialArea = calculatePolygonArea(polygonPoints);
let initialPopulation = Math.round(initialArea * populationDensity);
document.getElementById("area").textContent = initialArea.toFixed(2);
document.getElementById("population").textContent = initialPopulation.toLocaleString();


    </script>
</body>
</html>