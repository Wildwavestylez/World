<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expanze polygonu s rozlohou a obyvateli</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        #map {
            width: 100%;
            height: 90vh;
        }
        #info {
            padding: 10px;
            background: white;
            border-top: 1px solid #ccc;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
     
   <div id="info">
        <button id="buildGarage" onclick="placeGarage()">Postavit gar√°≈æ √∫dr≈æby</button>
        <button onclick="buyMaintenanceCar()">Koupit √∫dr≈æbov√© auto</button>
        <button onclick="startMaintenance()">Vyslat √∫dr≈æbu</button>
    Rozloha: <span id="area">0</span> km¬≤ | 
    Poƒçet obyvatel: <span id="population">0</span> | 
    Pen√≠ze: <span id="money">20000</span> Kƒç
</div>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map = L.map('map').setView([49.1090089, 13.8666047], 15); // Lƒçovice jako start
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap'
        }).addTo(map);

        let center = [49.1090089, 13.8666047];

        let polygonPoints = [
            [center[0] + 0.002, center[1] - 0.002],
            [center[0] + 0.002, center[1] + 0.002],
            [center[0] - 0.002, center[1] + 0.002],
            [center[0] - 0.002, center[1] - 0.002]
        ];

        let polygon = L.polygon(polygonPoints, { color: 'blue' }).addTo(map);

        let blockedPoints = {};
        let moveTracker = Array(polygonPoints.length).fill(0);

        let populationDensity = 130; // Hustota zalidnƒõn√≠ (obyvatel/km¬≤) ‚Äì m≈Ø≈æe se upravit podle oblasti

 // Definice ikony pro √∫dr≈æbov√© auto
const maintenanceVehicleIcon = L.icon({
    iconUrl: 'https://i.imgur.com/Cwm3M4Z.png',
    iconSize: [24, 24]
});        
        
           // Funkce pro naƒçten√≠ silniƒçn√≠ s√≠tƒõ z Overpass API
         function loadRoads() {
            var overpassQuery = `[out:json];
                way["highway"~"primary|trunk|secondary|tertiary"](49.06,13.80,49.13,13.86);
                out geom;`;
            var overpassUrl = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(overpassQuery)}`;

            fetch(overpassUrl)
                .then(response => response.json())
                .then(data => {
                    data.elements.forEach(element => {
                        if (element.type === "way" && element.geometry) {
                            var latlngs = element.geometry.map(coord => [coord.lat, coord.lon]);
                            L.polyline(latlngs, { color: 'blue', weight: 2 }).addTo(map);
                        }
                    });
                })
                .catch(error => console.error("Chyba p≈ôi naƒç√≠t√°n√≠ silnic:", error));
        }

        // Naƒç√≠st silnice po naƒçten√≠ mapy
        loadRoads();

         let roadLayer = L.layerGroup().addTo(map);

   let roads = []; // Seznam v≈°ech √∫sek≈Ø silnic

function getMaintenancePath(startLocation) {
    let path = [];
    let closestRoad = findNearestRoad(startLocation);
    
    if (!closestRoad) return path; // Pokud nen√≠ bl√≠zk√° silnice, nevrac√≠me nic

    let currentSegment = closestRoad;
    
    while (path.length < 50) { // Max d√©lka trasy, aby se nekoneƒçnƒõ necyklilo
        path.push(currentSegment.coordinates);
        let nextSegment = findNextRoadSegment(currentSegment);
        if (!nextSegment) break;
        currentSegment = nextSegment;
    }

    return path;
}

function findNearestRoad(location) {
    let nearestRoad = null;
    let minDistance = Infinity;

    roadSegments.forEach(segment => {
        let dist = distance(location, segment.coordinates[0]); // Prvn√≠ bod silnice
        if (dist < minDistance) {
            minDistance = dist;
            nearestRoad = segment;
        }
    });

    return nearestRoad;
}

function findNextRoadSegment(currentSegment) {
    let nextSegment = null;

    roadSegments.forEach(segment => {
        if (segment !== currentSegment && isConnected(currentSegment, segment)) {
            nextSegment = segment;
        }
    });

    return nextSegment;
}

function isConnected(segmentA, segmentB) {
    let lastPointA = segmentA.coordinates[segmentA.coordinates.length - 1];
    let firstPointB = segmentB.coordinates[0];

    return distance(lastPointA, firstPointB) < 0.001; // Men≈°√≠ ne≈æ 100m
}

// V√Ωpoƒçet vzd√°lenosti dvou bod≈Ø
function distance(coord1, coord2) {
    let latDiff = coord1[0] - coord2[0];
    let lonDiff = coord1[1] - coord2[1];
    return Math.sqrt(latDiff * latDiff + lonDiff * lonDiff);
}


let roadSegments = []; // Glob√°ln√≠ promƒõnn√° pro uchov√°n√≠ segment≈Ø silnic

function fetchRoads(bounds) {
    let bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
    let query = `
        [out:json];
        (
            way["highway"="primary"](${bbox});
            way["highway"="secondary"](${bbox});
            way["highway"="tertiary"](${bbox});
        );
        out geom;
    `;

    fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`)
        .then(response => response.json())
        .then(data => {
            if (!data.elements || data.elements.length === 0) {
                console.warn("‚ùå ≈Ω√°dn√© nov√© silnice nenalezeny!");
                return;
            }

            console.log(`‚úÖ Naƒçteno ${data.elements.length} nov√Ωch silnic`);

            data.elements.forEach(way => {
                let coordinates = way.geometry.map(point => [point.lat, point.lon]);
                let segments = splitRoadIntoSegments(coordinates, 200); // Rozdƒõlen√≠ na 200m √∫seky

                segments.forEach(segment => {
                    let polyline = L.polyline(segment, { color: 'red', weight: 3 }).addTo(roadLayer);

                    roadSegments.push({
                        coordinates: segment,
                        polyline: polyline,
                        status: "red" // Nov√© silnice jsou v≈ædy "ƒçerven√©"
                    });
                });
            });

            console.log(`üìå Celkov√Ω poƒçet silniƒçn√≠ch √∫sek≈Ø: ${roadSegments.length}`);
        })
        .catch(error => console.error("Chyba p≈ôi naƒç√≠t√°n√≠ silnic:", error));
}

// Funkce pro rozdƒõlen√≠ silnice na √∫seky po 200 metrech
function splitRoadIntoSegments(coords, segmentLength) {
    let segments = [];
    let currentSegment = [];
    let accumulatedDistance = 0;

    for (let i = 0; i < coords.length - 1; i++) {
        let pointA = L.latLng(coords[i]);
        let pointB = L.latLng(coords[i + 1]);
        let distance = pointA.distanceTo(pointB);

        if (accumulatedDistance + distance >= segmentLength) {
            segments.push([...currentSegment, pointB]);
            currentSegment = [pointB];
            accumulatedDistance = 0;
        } else {
            currentSegment.push(pointB);
            accumulatedDistance += distance;
        }
    }

    if (currentSegment.length > 1) {
        segments.push(currentSegment);
    }

    return segments;
}

// Naƒçten√≠ silnic po otev≈ôen√≠ mapy
fetchRoads(map.getBounds());
map.on('moveend', () => {
    fetchRoads(map.getBounds());
});
        function getCentroid(points) {
            let latSum = 0, lngSum = 0;
            points.forEach(p => { latSum += p[0]; lngSum += p[1]; });
            return [latSum / points.length, lngSum / points.length];
        }

        function movePointAway(point, center, distance) {
            let latDiff = point[0] - center[0];
            let lngDiff = point[1] - center[1];
            let length = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
            let scale = distance / length;
            return [point[0] + latDiff * scale, point[1] + lngDiff * scale];
        }

        function calculatePolygonArea(points) {
            let earthRadius = 6371; // Polomƒõr Zemƒõ v km
            let area = 0;
            let n = points.length;

            for (let i = 0; i < n; i++) {
                let p1 = points[i];
                let p2 = points[(i + 1) % n];

                let lat1 = p1[0] * Math.PI / 180;
                let lon1 = p1[1] * Math.PI / 180;
                let lat2 = p2[0] * Math.PI / 180;
                let lon2 = p2[1] * Math.PI / 180;

                area += (lon2 - lon1) * (2 + Math.sin(lat1) + Math.sin(lat2));
            }

            area = Math.abs(area * earthRadius * earthRadius / 2);
            return area;
        }

        function expandPolygon() {
            let center = getCentroid(polygonPoints);
            let totalPoints = polygonPoints.length;
            let maxWaitTurns = Math.floor(1.5 * totalPoints);

            let availablePoints = polygonPoints
                .map((point, index) => ({ point, index }))
                .filter(({ index }) => !blockedPoints[index]);

            if (availablePoints.length === 0) return;

            let forcedMoveIndex = moveTracker.indexOf(Math.max(...moveTracker));
            let mustMove = moveTracker[forcedMoveIndex] >= maxWaitTurns;

            let selectedIndex;
            if (mustMove) {
                selectedIndex = forcedMoveIndex;
            } else {
                let randomPoint = availablePoints[Math.floor(Math.random() * availablePoints.length)];
                selectedIndex = randomPoint.index;
            }

            polygonPoints[selectedIndex] = movePointAway(polygonPoints[selectedIndex], center, 0.0027);

            moveTracker[selectedIndex] = 0;
            blockedPoints[selectedIndex] = Date.now() + (totalPoints / 2) * 1000;

            for (let i = 0; i < moveTracker.length; i++) {
                if (i !== selectedIndex) moveTracker[i]++;
            }

            for (let i = 0; i < polygonPoints.length; i++) {
                let p1 = polygonPoints[i];
                let p2 = polygonPoints[(i + 1) % polygonPoints.length];

                let distance = Math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2);
                if (distance > 0.009) {
                    let midPoint = [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];
                    polygonPoints.splice(i + 1, 0, midPoint);
                    moveTracker.splice(i + 1, 0, 0);
                    break;
                }
            }

            polygon.setLatLngs(polygonPoints);

            let area = calculatePolygonArea(polygonPoints);
            let population = Math.round(area * populationDensity);

            document.getElementById("area").textContent = area.toFixed(2);
            document.getElementById("population").textContent = population.toLocaleString();
        }

        function unlockBlockedPoints() {
            let currentTime = Date.now();
            for (let index in blockedPoints) {
                if (currentTime >= blockedPoints[index]) {
                    delete blockedPoints[index];
                }
            }
        }

        setInterval(() => {
            expandPolygon();
            unlockBlockedPoints();
        }, 1000);

        let money = 20000; // Poƒç√°teƒçn√≠ stav penƒõz
    let tollBooths = []; // Seznam m√Ωtn√Ωch bran
        let garagePrice = 100;
        let maintenanceCarPrice = 50;
        let garages = [];
        let maintenanceCars = [];

      function updateMoneyDisplay() {
            document.getElementById("money").textContent = money.toLocaleString();
        }

    function placeTollBooth(latlng) {
        if (money < 5000) {
            alert("Nem√°≈° dost penƒõz na m√Ωtnou br√°nu!");
            return;
        }

        money -= 5000; // Odeƒçten√≠ ceny za m√Ωtnou br√°nu
        updateMoneyDisplay();

        let icon = L.icon({
            iconUrl: "https://i.imgur.com/U2n0VLa.png",
            iconSize: [32, 32]
        });

        let marker = L.marker(latlng, { icon }).addTo(map);
        tollBooths.push(marker);

        // Generov√°n√≠ penƒõz ka≈æd√Ωch 20 sekund
        setInterval(() => {
            money += 25;
            updateMoneyDisplay();
        }, 20000);
    }

    // P≈ôid√°n√≠ mo≈ænosti kliknut√≠m na silnici um√≠stit m√Ωtnou br√°nu
    map.on("click", function (e) {
        let clickedLatLng = e.latlng;
        placeTollBooth(clickedLatLng);
    });

    updateMoneyDisplay();

       
function placeGarage() {
    if (money < garagePrice) {
        alert("Nedostatek penƒõz!");
        return;
    }

    money -= garagePrice;
    garagePrice += 500; // Ka≈æd√° dal≈°√≠ gar√°≈æ je dra≈æ≈°√≠

    map.once('click', function (event) {
        let garage = {
            location: event.latlng,
            marker: L.marker(event.latlng, { icon: L.icon({ iconUrl: 'https://i.imgur.com/puN4S0i.jpeg', iconSize: [32, 32] }) })
        };

        garage.marker.addTo(map).bindPopup("Gar√°≈æ √∫dr≈æby");
        garages.push(garage);
    });
}

// Tlaƒç√≠tko pro stavbu gar√°≈æe
document.getElementById('buildGarage').addEventListener('click', placeGarage);


        function buyMaintenanceCar() {
            if (garages.length === 0) {
                alert("Nejd≈ô√≠v mus√≠≈° postavit gar√°≈æ!");
                return;
            }

            if (money < maintenanceCarPrice) {
                alert("Nem√°≈° dost penƒõz na √∫dr≈æbov√© auto!");
                return;
            }

            money -= maintenanceCarPrice;
            updateMoneyDisplay();

            let icon = L.icon({
                iconUrl: "https://i.imgur.com/Cwm3M4Z.png",
                iconSize: [32, 32]
            });

            let garage = garages[0].getLatLng();
            let marker = L.marker(garage, { icon }).addTo(map);
            maintenanceCars.push(marker);

            maintenanceCarPrice += 200;
            console.log("√ödr≈æbov√© auto koupeno a zaparkov√°no v gar√°≈æi.");
        }

function sendMaintenanceVehicle(garageLocation) {
    if (!roadSegments || roadSegments.length === 0) {
        console.warn("üöß ≈Ω√°dn√© dostupn√© silnice k opravƒõ!");
        return;
    }

    let vehicle = maintenanceVehicles.find(v => !v.moving);
    if (!vehicle) {
        console.warn("üöó V≈°echna √∫dr≈æbov√° auta jsou obsazena!");
        return;
    }

    function findNextSegment() {
        return roadSegments.find(segment => segment.status === "red" || segment.status === "orange");
    }

    function moveVehicleToSegment(segment) {
        if (!segment) {
            console.log("‚úÖ V≈°echny silnice jsou opraven√©! Auto se vrac√≠ do gar√°≈æe.");
            vehicle.marker.setLatLng(garageLocation);
            vehicle.moving = false;
            return;
        }

        console.log(`üõ† Pos√≠l√°m √∫dr≈æbu na silnici: ${segment.coordinates[0]}`);

        vehicle.moving = true;
        let route = [...segment.coordinates];
        let speed = 50 / 3600; // 50 km/h v m/s
        let currentIndex = 0;

        function moveVehicle() {
            if (currentIndex < route.length) {
                let nextPoint = L.latLng(route[currentIndex]);
                vehicle.marker.setLatLng(nextPoint);
                currentIndex++;
                setTimeout(moveVehicle, 1000);
            } else {
                console.log("üöß Oprava silnice zah√°jena...");
                setTimeout(() => {
                    repairSegment(segment);
                    console.log("‚úÖ Silnice opravena!");
                    moveVehicleToSegment(findNextSegment()); // Hled√° dal≈°√≠ √∫sek
                }, 20000); // Oprava trv√° 20 vte≈ôin
            }
        }

        moveVehicle();
    }

    moveVehicleToSegment(findNextSegment());
}

// Funkce pro opravu √∫seku a zmƒõnu barvy
function repairSegment(segment) {
    if (segment.status === "red") {
        segment.status = "orange";
        segment.polyline.setStyle({ color: "orange" });
    } else if (segment.status === "orange") {
        segment.status = "green";
        segment.polyline.setStyle({ color: "green" });
    }
}

// Oprava √∫seku
function repairSegment(segment) {
    if (segment.status === "red") {
        segment.status = "orange";
        segment.polyline.setStyle({ color: "orange" });
    } else if (segment.status === "orange") {
        segment.status = "green";
        segment.polyline.setStyle({ color: "green" });
    } else {
        console.log("‚ùå Chyba: Neplatn√Ω stav silnice");
    }
}
}
// Oprava √∫seku
function repairSegment(segment) {
    if (segment.status === "red") {
        segment.status = "orange";
        segment.polyline.setStyle({ color: "orange" });
    } else if (segment.status === "orange") {
        segment.status = "green";
        segment.polyline.setStyle({ color: "green" });
    } else {
        console.log("‚ùå Chyba: Neplatn√Ω stav silnice");
    }
}
    </script>
</body>
</html>
